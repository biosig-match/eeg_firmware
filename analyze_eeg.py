#!/usr/bin/env python3
"""
EEG Data Analysis Script using MNE-Python.
- Loads data from a CSV file generated by ble_receiver.py.
- Automatically finds the latest CSV file if no path is provided.
- Creates an MNE Raw object.
- Computes and plots the Power Spectral Density (PSD).
- Calculates quantitative metrics for signal quality assessment.
- Saves the PSD plot and quality report into a dedicated results folder.
"""

import sys
import pandas as pd
import mne
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import glob
import os

# --- Results output directory ---
RESULTS_DIR = "analysis_results"

# --- Sampling frequency settings ---
SAMPLING_FREQ = 250  # Hz (default)

# LSB to microvolt conversion for ADS1299 (V_ref=4.5V, Gain=24x).
SCALING_FACTOR = (4.5 / 24.0) / (2**15) * 1e6 # uV/LSB

# PSD display scale (MNE default is dB)
PSD_DB = True
PSD_FMIN = 1.0
PSD_FMAX = 60.0

# DC offset removal (avoid PSD floor at ~0Hz)
REMOVE_DC = True

# Spike notch (for PSD display only)
APPLY_SPIKE_NOTCH = True
SPIKE_NOTCH_FREQS = [
    3.0,
    6.0, 16.0, 26.0, 36.0, 46.0, 56.0,
    10.0, 20.0, 30.0, 40.0, 50.0, 60.0,
    14.0, 24.0, 34.0, 44.0, 54.0,
]
SPIKE_NOTCH_Q = 30.0

# Mains notch (for PSD display only)
APPLY_MAINS_NOTCH = True
MAINS_NOTCH_Q = 30.0

# Bandpass (for PSD display only)
APPLY_BANDPASS = True
BANDPASS_LOW_HZ = 1.0
BANDPASS_HIGH_HZ = 30.0

# PSD output mode
SAVE_RAW_PSD = True
SAVE_CLEAN_PSD = True
SAVE_STANDARD_PSD = True

# Standard PSD settings (MNE-style defaults)
STD_PSD_FMIN = 1.0
STD_PSD_FMAX = 40.0
STD_PSD_NFFT = 1024
STD_PSD_OVERLAP = 512

# 電源ノイズの周波数 (お住まいの地域に合わせて50または60に変更)
POWER_LINE_FREQ = 50.0  # Hz (e.g., 50 for East Japan, 60 for West Japan)

# --- 評価の閾値 ---
# 標準偏差がこの値 (uV) より小さい場合、接触不良の可能性を警告
STD_DEV_THRESHOLD_LOW = 1.0
# 標準偏差がこの値 (uV) より大きい場合、体動ノイズの可能性を警告
STD_DEV_THRESHOLD_HIGH = 200.0
# 電源ノイズ比がこの値より大きい場合、ノイズが多いと判断
POWER_LINE_RATIO_THRESHOLD = 5.0
# 高周波ノイズ比がこの値より大きい場合、筋電ノイズの可能性を警告
HIGH_FREQ_RATIO_THRESHOLD = 1.0


def _load_bitbrain_info(directory: str, signal_id: str):
    info_path = os.path.join(directory, "info.json")
    if not os.path.exists(info_path):
        return None
    try:
        import json
        with open(info_path, "r", encoding="utf-8") as f:
            info = json.load(f)
    except Exception:
        return None
    for sig in info.get("signals", []):
        if sig.get("id") == signal_id:
            return sig
    return None


def analyze_eeg_data(filepath: str):
    """CSVファイルからEEGデータを読み込み、処理・分析・評価・保存を行う"""
    print(f"--- Analyzing EEG Data from: {filepath} ---")

    print(f"Results will be saved in the '{RESULTS_DIR}/' folder.")

    # 出力ファイル名のベースを作成 (e.g., "eeg_data_20231026_123000")
    base_filename = os.path.basename(os.path.splitext(filepath)[0])

    try:
        df = pd.read_csv(filepath)
    except FileNotFoundError:
        print(f"Error: File not found at '{filepath}'")
        return

    # --- 1. データ準備 ---
    raw_ch_names = [col for col in df.columns if col not in ['timestamp', 'sample_index', 'trigger']]
    num_channels = len(raw_ch_names)
    print(f"Found {num_channels} channels: {raw_ch_names}")

    # Normalize channel names: "CH1 (LSB)" -> "CH1"
    def normalize_ch_name(name: str) -> str:
        if name.endswith(" (LSB)"):
            return name[:-6]
        if name.endswith(" (uV)"):
            return name[:-5]
        return name

    # Unit detection (header / metadata)
    has_lsb = any(name.endswith(" (LSB)") for name in raw_ch_names)
    has_uv = any(name.endswith(" (uV)") for name in raw_ch_names)
    sampling_freq = SAMPLING_FREQ
    data_scale_to_uv = None
    unit_label = "unknown"

    ch_names = [normalize_ch_name(name) for name in raw_ch_names]
    data_values = df[raw_ch_names].values.T

    bitbrain_eeg = False
    if not has_lsb and not has_uv:
        base_name = os.path.splitext(os.path.basename(filepath))[0]
        info = _load_bitbrain_info(os.path.dirname(filepath), base_name)
        if info and info.get("signal_type") == "eeg":
            bitbrain_eeg = True
            sampling_freq = info.get("sampling_rate", SAMPLING_FREQ)
            print(f"Detected bitbrain info.json: sampling_rate={sampling_freq} Hz")
            median_abs = float(np.median(np.abs(data_values)))
            if median_abs > 1000.0:
                data_scale_to_uv = 1e-3  # nV -> uV
                unit_label = "nV"
            else:
                data_scale_to_uv = 1.0
                unit_label = "uV"
        else:
            data_scale_to_uv = 1.0
            unit_label = "uV?"
            print("Warning: Unknown unit. Assuming uV.")
    elif has_uv and not has_lsb:
        data_scale_to_uv = 1.0
        unit_label = "uV"
    elif has_lsb:
        data_scale_to_uv = SCALING_FACTOR
        unit_label = "LSB"
    else:
        data_scale_to_uv = 1.0
        unit_label = "uV?"
        print("Warning: Unknown unit. Assuming uV.")

    eeg_data_uv = data_values * data_scale_to_uv
    print(f"Detected unit: {unit_label} (scaled to uV).")
    if unit_label == "LSB":
        adc_max = (2**15 - 1)
        adc_min = -2**15
        near_max = np.any(data_values >= 0.95 * adc_max)
        near_min = np.any(data_values <= 0.95 * adc_min)
        if near_max or near_min:
            print("Warning: ADC saturation detected (near 16-bit limits).")

    if REMOVE_DC:
        eeg_data_uv = eeg_data_uv - np.mean(eeg_data_uv, axis=1, keepdims=True)
        print("DC offset removed (per channel).")

    # PSD preprocessing for display
    eeg_data_uv_psd = eeg_data_uv.copy()
    if APPLY_SPIKE_NOTCH:
        for f0 in SPIKE_NOTCH_FREQS:
            b, a = signal.iirnotch(f0, SPIKE_NOTCH_Q, sampling_freq)
            eeg_data_uv_psd = signal.filtfilt(b, a, eeg_data_uv_psd, axis=1)
        print(f"Spike-notch applied for PSD: {SPIKE_NOTCH_FREQS} Hz")
    if APPLY_MAINS_NOTCH:
        b, a = signal.iirnotch(POWER_LINE_FREQ, MAINS_NOTCH_Q, sampling_freq)
        eeg_data_uv_psd = signal.filtfilt(b, a, eeg_data_uv_psd, axis=1)
        print(f"Mains-notch applied for PSD: {POWER_LINE_FREQ} Hz")
    if APPLY_BANDPASS:
        nyq = 0.5 * sampling_freq
        low = BANDPASS_LOW_HZ / nyq
        high = BANDPASS_HIGH_HZ / nyq
        b, a = signal.butter(2, [low, high], btype='band')
        eeg_data_uv_psd = signal.filtfilt(b, a, eeg_data_uv_psd, axis=1)
        print(f"Bandpass applied for PSD: {BANDPASS_LOW_HZ}-{BANDPASS_HIGH_HZ} Hz")

    eeg_data_volts = eeg_data_uv * 1e-6
    eeg_data_volts_psd = eeg_data_uv_psd * 1e-6
    
    # --- 2. MNE Rawオブジェクトの作成 ---
    info = mne.create_info(ch_names=ch_names, sfreq=sampling_freq, ch_types='eeg')
    raw_quality = mne.io.RawArray(eeg_data_volts, info)
    raw_psd = mne.io.RawArray(eeg_data_volts_psd, info)
    print("\n--- MNE Raw object created successfully ---")
    print(raw_quality)

    # --- 3. PSDの計算、プロット、保存 ---
    print("\n--- Plotting and Saving Power Spectral Density (PSD) ---")
    if PSD_DB:
        print("Note: PSD is displayed in dB; negative values are normal.")
    if SAVE_RAW_PSD:
        raw_psd_fig = raw_quality.compute_psd(
            method="welch",
            fmin=STD_PSD_FMIN,
            fmax=STD_PSD_FMAX,
            n_fft=STD_PSD_NFFT,
            n_overlap=STD_PSD_OVERLAP,
            average="mean",
        ).plot(
            picks='eeg',
            average=False,
            spatial_colors=False,
            dB=PSD_DB,
            show=False
        )
        raw_psd_filepath = os.path.join(RESULTS_DIR, f"{base_filename}_psd_raw.png")
        raw_psd_fig.savefig(raw_psd_filepath)
        if len(ch_names) <= 12:
            ax = raw_psd_fig.axes[0]
            ax.legend(ch_names, loc="upper right", fontsize="x-small")
        print(f"Raw PSD plot saved to: {raw_psd_filepath}")

    if SAVE_CLEAN_PSD:
        clean_psd_fig = raw_psd.compute_psd(
            method="welch",
            fmin=STD_PSD_FMIN,
            fmax=STD_PSD_FMAX,
            n_fft=STD_PSD_NFFT,
            n_overlap=STD_PSD_OVERLAP,
            average="mean",
        ).plot(
            picks='eeg',
            average=False,
            spatial_colors=False,
            dB=PSD_DB,
            show=False
        )
        clean_psd_filepath = os.path.join(RESULTS_DIR, f"{base_filename}_psd_clean.png")
        clean_psd_fig.savefig(clean_psd_filepath)
        if len(ch_names) <= 12:
            ax = clean_psd_fig.axes[0]
            ax.legend(ch_names, loc="upper right", fontsize="x-small")
        print(f"Clean PSD plot saved to: {clean_psd_filepath}")

    if SAVE_STANDARD_PSD:
        std_psd = raw_quality.compute_psd(
            method="welch",
            fmin=STD_PSD_FMIN,
            fmax=STD_PSD_FMAX,
            n_fft=STD_PSD_NFFT,
            n_overlap=STD_PSD_OVERLAP,
            average="mean",
        )
        std_fig = std_psd.plot(
            picks="eeg",
            average=True,
            spatial_colors=False,
            dB=True,
            show=False,
        )
        std_filepath = os.path.join(RESULTS_DIR, f"{base_filename}_psd_standard.png")
        std_fig.savefig(std_filepath)
        print(f"Standard PSD plot saved to: {std_filepath}")

    print("Close the plot window(s) to continue...")
    plt.show()

    # --- 4. 定量的な信号品質評価 ---
    print("\n--- Quantitative Signal Quality Assessment ---")
    
    # 全チャンネルのPSDデータを取得
    psds, freqs = raw_quality.compute_psd(fmin=1.0, fmax=100.0).get_data(return_freqs=True)
    
    # 結果を格納するリスト
    quality_results = []

    for i, ch_name in enumerate(ch_names):
        # --- 指標1: 標準偏差 (Standard Deviation) ---
        std_dev = np.std(eeg_data_uv[i, :])
        if std_dev < STD_DEV_THRESHOLD_LOW:
            std_status = "FLAT (接触不良?)"
        elif std_dev > STD_DEV_THRESHOLD_HIGH:
            std_status = "HIGH (体動ノイズ?)"
        else:
            std_status = "OK"

        # --- 指標2: 電源ノイズ比 (Power-Line Noise Ratio) ---
        noise_band = (freqs >= POWER_LINE_FREQ - 1) & (freqs <= POWER_LINE_FREQ + 1)
        signal_band1 = (freqs >= POWER_LINE_FREQ - 3) & (freqs <= POWER_LINE_FREQ - 1.5)
        signal_band2 = (freqs >= POWER_LINE_FREQ + 1.5) & (freqs <= POWER_LINE_FREQ + 3)
        
        power_noise = np.mean(psds[i, noise_band])
        power_signal = np.mean(np.concatenate((psds[i, signal_band1], psds[i, signal_band2])))
        
        pln_ratio = power_noise / power_signal if power_signal > 1e-12 else 0
        pln_status = "NOISY" if pln_ratio > POWER_LINE_RATIO_THRESHOLD else "OK"

        # --- 指標3: 高周波ノイズ比 (High-Frequency Noise Ratio) ---
        eeg_band = (freqs >= 1.0) & (freqs < 30.0)
        hf_band = (freqs >= 30.0) & (freqs < 100.0)

        power_eeg = np.mean(psds[i, eeg_band])
        power_hf = np.mean(psds[i, hf_band])
        
        hf_ratio = power_hf / power_eeg if power_eeg > 1e-12 else 0
        hf_status = "HIGH (筋電ノイズ?)" if hf_ratio > HIGH_FREQ_RATIO_THRESHOLD else "OK"

        quality_results.append({
            "Channel": ch_name,
            "Std Dev (uV)": f"{std_dev:.1f}",
            "Std Status": std_status,
            "PLN Ratio": f"{pln_ratio:.1f}",
            "PLN Status": pln_status,
            "HF Ratio": f"{hf_ratio:.2f}",
            "HF Status": hf_status,
        })

    # --- 5. 結果を表形式で表示し、CSVに保存 ---
    if not quality_results:
        print("Could not generate quality results.")
        return
        
    # --- 品質評価結果を結果フォルダにCSVファイルとして保存 ---
    try:
        quality_df = pd.DataFrame(quality_results)
        quality_filepath = os.path.join(RESULTS_DIR, f"{base_filename}_quality.csv")
        # Excelで文字化けしないように encoding='utf-8-sig' を指定
        quality_df.to_csv(quality_filepath, index=False, encoding='utf-8-sig')
        print(f"\nSignal quality report saved to: {quality_filepath}")
    except Exception as e:
        print(f"\nError saving quality report to CSV: {e}")

    # ヘッダーの作成と表示
    headers = quality_results[0].keys()
    header_str = f"{' | '.join(f'{h:<20}' for h in headers)}"
    print(header_str)
    print("-" * len(header_str))

    # 各チャンネルの結果を表示
    for result in quality_results:
        row_str = f"{' | '.join(f'{str(v):<20}' for v in result.values())}"
        print(row_str)

    print("\n--- Analysis Complete ---")


if __name__ == "__main__":
    csv_file_path = ""
    DATA_DIR = "eeg_data"
    # コマンドライン引数でファイルが指定されていれば、それを使用
    if len(sys.argv) > 1:
        csv_file_path = sys.argv[1]
    # 指定がなければ、最新のeeg_data_*.csvファイルを自動で探す
    else:
        print("No file path provided. Searching for the latest eeg_data_*.csv file...")
        # eeg_data_で始まり.csvで終わるファイルのリストを取得
        search_pattern = os.path.join(DATA_DIR, 'eeg_data_*.csv')
        list_of_files = glob.glob(search_pattern)

        if not list_of_files:
            print("Error: No 'eeg_data_*.csv' files found in the current directory.")
            sys.exit(1)
        # ファイル作成時刻が最も新しいファイルを取得
        latest_file = max(list_of_files, key=os.path.getctime)
        csv_file_path = latest_file
    
    analyze_eeg_data(csv_file_path)

